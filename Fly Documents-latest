<!--
+ ================== +
|   Fly Documents    |
+ ------------------ +
|   Ja-Jp     v2.3.5 |
|  release  25/11/16 |
|   catmakura@2025   |
+ ================== +
-->
<!DOCTYPE html>
<html lang="ja-jp">
<head>
<meta charset="UTF-8">
<title>Documents - ファイルを安全に編集</title>
<link rel="icon" href="Doc-icon.png" type="image/x-icon">
<style>
textarea { width: 100%; height: 400px; }
</style>
</head>
<body>

<h2>ファイル編集ツール</h2>
<h3>Documents v2.3.5 安定版</h3>

<button id="openBtn">ファイルを開く</button>
<button id="createBtn">新規ファイル作成</button>
<button id="saveBtn" disabled>保存</button>
<button id="undoBtn" disabled>元に戻す</button>
<button id="redoBtn" disabled>やり直し</button>

<p>ファイル名: <input type="text" id="filename" placeholder="ファイル名を変更可能"></p>

<p>
編集モード: 
<select id="mode">
  <option value="text">テキストで編集</option>
  <option value="base64">Base64で編集（バイナリ用）</option>
</select>
</p>

<textarea id="editor" placeholder="ファイル内容がここに表示されます"></textarea>

<script>
// 変数の初期化
let fileHandle = null;
let originalFileName = "";
let historyStack = [];  // undoのための履歴スタック
let redoStack = [];     // redoのための履歴スタック
let isUndoRedoInProgress = false;  // undoやredoが進行中かを示すフラグ

// Base64 エンコード
function arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
}

// Base64 デコード
function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
}

// エディタ内容の履歴を保存
function saveEditorState() {
    if (isUndoRedoInProgress) return;  // undo/redoが進行中のときは履歴を追加しない
    historyStack.push(document.getElementById("editor").value);  // 現在のエディタ内容を履歴に追加
    redoStack = [];  // redoスタックはリセット
    updateUndoRedoButtons();
}

// undoボタンの状態を更新
function updateUndoRedoButtons() {
    document.getElementById("undoBtn").disabled = historyStack.length === 0;
    document.getElementById("redoBtn").disabled = redoStack.length === 0;
}

// undo
document.getElementById("undoBtn").onclick = () => {
    if (historyStack.length > 0) {
        isUndoRedoInProgress = true;
        const previousState = historyStack.pop();  // 最新の履歴を取り出す
        redoStack.push(document.getElementById("editor").value);  // 現在の状態をredoスタックに保存
        document.getElementById("editor").value = previousState;  // エディタに前の状態を反映
        updateUndoRedoButtons();
        isUndoRedoInProgress = false;
    }
};

// redo
document.getElementById("redoBtn").onclick = () => {
    if (redoStack.length > 0) {
        isUndoRedoInProgress = true;
        const nextState = redoStack.pop();  // 最新のredo履歴を取り出す
        historyStack.push(document.getElementById("editor").value);  // 現在の状態をhistoryスタックに保存
        document.getElementById("editor").value = nextState;  // エディタに次の状態を反映
        updateUndoRedoButtons();
        isUndoRedoInProgress = false;
    }
};

// ① ファイルを開く
document.getElementById("openBtn").onclick = async () => {
    try {
        [fileHandle] = await window.showOpenFilePicker();
        const file = await fileHandle.getFile();
        originalFileName = file.name;

        const mode = document.getElementById("mode").value;
        const buffer = await file.arrayBuffer();

        if (mode === "text") {
            try {
                document.getElementById("editor").value = new TextDecoder("utf-8", { fatal: false }).decode(buffer);
            } catch (err) {
                alert("テキストの読み込みに失敗しました");
                console.error(err);
            }
        } else {
            try {
                document.getElementById("editor").value = arrayBufferToBase64(buffer);
            } catch (err) {
                alert("Base64の読み込みに失敗しました");
                console.error(err);
            }
        }

        // ファイル名入力欄に反映
        document.getElementById("filename").value = originalFileName;
        document.getElementById("saveBtn").disabled = false;
        historyStack = []; // 新しくファイルを開いたら履歴をリセット
        redoStack = [];
        updateUndoRedoButtons();
    } catch (err) {
        alert("ファイルの選択に失敗しました");
        console.error(err);
    }
};

// ② 新規ファイル作成
document.getElementById("createBtn").onclick = async () => {
    if (document.getElementById("editor").value !== "" && !confirm("変更が保存されていません。新しいファイルを作成しますか？")) {
        return;
    }

    const newFileName = prompt("新しいファイル名を入力してください（拡張子も含む）", "新しいファイル.txt");

    if (newFileName && !/[^a-zA-Z0-9_\-\.]/.test(newFileName)) {
        // 新規ファイルの設定
        document.getElementById("editor").value = "";
        document.getElementById("filename").value = newFileName;
        document.getElementById("saveBtn").disabled = false;

        // fileHandleもリセット
        fileHandle = null;
        originalFileName = "";
        historyStack = []; // 履歴をリセット
        redoStack = [];
        updateUndoRedoButtons();
    } else {
        alert("無効なファイル名です。特殊文字が含まれています。");
    }
};

// ③ 保存（ファイル名変更有無で処理分岐）
document.getElementById("saveBtn").onclick = async () => {
    const filenameInput = document.getElementById("filename").value.trim();
    if (!filenameInput) {
        alert("ファイル名を入力してください");
        return;
    }

    const mode = document.getElementById("mode").value;
    let output;

    if (mode === "text") {
        output = new TextEncoder().encode(document.getElementById("editor").value);
    } else {
        try {
            output = new Uint8Array(base64ToArrayBuffer(document.getElementById("editor").value));
        } catch (e) {
            alert("Base64データが正しくありません");
            return;
        }
    }

    try {
        if (filenameInput === originalFileName && fileHandle) {
            const writable = await fileHandle.createWritable();
            await writable.write(output);
            await writable.close();
            alert(`元のファイル "${originalFileName}" を上書き保存しました`);
        } else {
            const newHandle = await window.showSaveFilePicker({ suggestedName: filenameInput });
            const writableNew = await newHandle.createWritable();
            await writableNew.write(output);
            await writableNew.close();
            alert(`新しい名前で保存しました: ${filenameInput}`);
        }
    } catch (err) {
        alert("保存に失敗しました");
        console.error(err);
    }
};

// エディタ内容が変更されるたびに履歴を保存
document.getElementById("editor").addEventListener("input", () => {
    if (!isUndoRedoInProgress) {
        saveEditorState();
    }
});
</script>

</body>
</html>
